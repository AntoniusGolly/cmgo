% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CM.calculateCenterline.r
\name{CM.calculateCenterline}
\alias{CM.calculateCenterline}
\title{Calculate channel centerline}
\usage{
CM.calculateCenterline(object, set = NULL)
}
\arguments{
\item{object}{the global object of type list containing data and parameters created with \code{\link[=CM.ini]{CM.ini()}}}

\item{set}{an optional argument for processing a specific data set, if \code{NULL} all available data sets are used}
}
\value{
returns the global data object extended by the centerline data \code{$cl} for the respective data set(s)
}
\description{
Calculate the centerline of the channel polygon in 5 steps:
\enumerate{
  \item creating Voronoi polygons of the bank points, convert to paths (line segments with two ends) and remove duplicates\cr
  \item filtering for path segments that lie within the banks\cr
  \item filtering for path segments that are dead ends (have less than 2 connected ends)\cr
  \item sorting of the centerline segments to generate centerline\cr
  \item smooth the centerline
}
}
\details{
\code{CM.calculateCenterline()} calculates the centerline of the channel polygon (Fig. 7).

\if{html}{\figure{06-processing.png}{options: width="800px" alt="Figure: processing"}}
\if{latex}{\figure{06-processing.pdf}{options: width=9cm}}
\emph{Figure 6: A visualization of the calculation of the centerline a) the channel polygon, b) the Voronoi polygons,
c) extraction of the centerline segments, d) smoothing of the centerline path.}

The function requires as input the channel polygon (Fig. 6a) which must be stored within the global data object
previously generated with \code{\link[=CM.generatePolygon]{CM.generatePolygon()}}.
The algorithm then creates Voronoi polygons around the bank points (Fig. 6b).
Voronoi polygons around points denote the areas within which all points are closest to that point. The polygons
are disassembled to single line segments. In Fig. 6b you can already notice a centerline evolving from the segments in
the middle of the channel polygon. To get only these segments a filtering (Fig. 7) is applied to the Voronoi segments.

\if{html}{\figure{07-filtering.png}{options: width="600px" alt="Figure: processing"}}
\if{latex}{\figure{07-filtering.pdf}{options: width=6cm}}
\emph{Figure 7: the filtering of the Voronoi segments: a) in blue all Voronoi segments, b) in red all segments fully within
the channel polygon, c) in green all segments without dead ends.}

To retrieve only the segments that represent the centerline all segments that do not lie entirely
within the channel banks are removed (Fig. 7b). In a second step dead ends are removed (Fig. 7c). Dead ends are
segments that branch from the centerline but are not part of it.

These centerline segments will be
chained to one consistent line and get smoothed (Fig. 7d). The degree of smoothing can be adjusted
through the parameter \code{centerline.smoothing.width} (defaults to the same value as
\code{bank.interpolate.max.dist}). This centerline represents the reference of the river, for which
length, local width and slope are calculated next. Note, that the length of the centerline has decreased
by the smoothing in d). It is important to understand, that the length of a river is not a well-defined measure.
The length of a river depends on the resolution of the bank points. Similar to
\href{https://en.wikipedia.org/wiki/Coast#Coastline_problem}{the coast line paradox}, the length depends on the
scale of the observations. Technically, a bended river is a fractal, which
means theoretically, the length diverges to infinity at an infinitely high resolution of the bank points.
However, practically there is an appropriate choice of a minimum feature size. Every user has to determine this
scale individually and should be aware of this choice. The decrease in length due to smoothing
is saved as value in the global data object under \code{cmgo.obj$data[[set]]$cl$length.factor}. A value of 0.95 means
that the length of the smoothed centerline is 95\% the length of the original centerline paths.
}
\examples{
# get demo data
# (find instructions on how to use own data in the documentation of CM.ini())
cmgo.obj = CM.ini("demo")

# generate the polygon from the bank points
cmgo.obj = CM.generatePolygon(cmgo.obj)

# calculate the centerline from the polygon
cmgo.obj = CM.calculateCenterline(cmgo.obj)

# check results
plot.par = CM.plotPlanView(cmgo.obj)

# change degree of smoothing, re-calculate centerline and plot
cmgo.obj$par$centerline.smoothing.width = 12
cmgo.obj = CM.calculateCenterline(cmgo.obj)
plot.par = CM.plotPlanView(cmgo.obj)

}
\author{
Antonius Golly
}
